#N canvas 122 41 1460 841 12;
#X floatatom 477 416 5 0 98 1 Feedback_(%) - -, f 5;
#X obj 527 140 r~ delayFeedback;
#N canvas 672 136 450 300 write_delay 0;
#X obj 73 103 +~;
#X obj 54 208 outlet~;
#X obj 54 26 inlet~;
#X obj 162 24 inlet~;
#X obj 73 147 delwrite~ combfilter 10000;
#X connect 0 0 4 0;
#X connect 2 0 0 0;
#X connect 2 0 1 0;
#X connect 3 0 0 1;
#X restore 376 188 pd write_delay;
#X obj 495 503 s~ delayFeedback;
#N canvas 923 426 463 405 read_delay 0;
#X obj 172 20 *~;
#X obj 238 -22 / 100;
#X obj 142 72 +~;
#X obj -43 -173 inlet~;
#X obj 142 151 outlet~;
#X obj 208 87 outlet~;
#X obj 238 -59 inlet;
#X obj 172 -115 vd~ combfilter;
#X obj 172 -148 /~ 44.1;
#X obj 172 -182 inlet~;
#X connect 0 0 2 1;
#X connect 0 0 5 0;
#X connect 1 0 0 1;
#X connect 2 0 4 0;
#X connect 3 0 2 0;
#X connect 6 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 7 0;
#X connect 9 0 8 0;
#X restore 376 461 pd read_delay;
#X obj 400 502 s~ output;
#X obj 332 713 dac~;
#N canvas 136 59 691 619 why_use_subpatches_here? 0;
#X text 55 10 Execution order • Much of the time \, the actual execution
order of pd audio rate objects need not concern us. • It is important
to remember that audio processing is done in blocks: these are audio
vectors (buffers): the default block size is 64 samples. Ordinarily
\, objects do not process audio on a sample by sample basis. pd ensures
that the order of execution is such \, that an audio rate objects’s
output block is not calculated \, until all the inputs for the same
block have been computed first. • However \, when working with delays
\, order does become important \, as we are relying on the past values
of samples. • It is important to write to the delay line before it
is read. • If the delay line is read before it is written to \, the
minimum delay it is possible to have is one audio block (e.g. 64 samples
or ca. 1.45 msecs at 44.1kHz sampling rate). This is \, of course \,
not a problem for long delays \, but for designing patches that use
shorter delays \, such as flangers and comb filters \, this becomes
a problematic limit. • One useful method of ensuring the correct
execution order is to put delay writers and delay readers in separate
subpatches. The order in which subpatches are connected \, guarantees
their order of execution. As long as the output of the delay line writer
is attached to the input of the delay line reader \, then the delay
line will always be written to before it is read.;
#X restore 109 314 pd why_use_subpatches_here?;
#X obj 376 606 *~;
#X obj 439 556 tgl 50 0 empty empty empty 17 7 0 10 -258113 -1 -1 0
1;
#X text 498 564 unmute;
#X obj 1006 363 osc~;
#X obj 1032 408 *~;
#X floatatom 1079 266 5 0 441000 1 To_delay_(samples) - -, f 5;
#X floatatom 861 295 5 0 22050 1 Frequency_(Hz) - -, f 5;
#X obj 1032 441 +~;
#X floatatom 1202 334 5 0 441000 1 From-delay_(samples) - -, f 5;
#X obj 1079 362 -;
#X obj 1079 296 t b f;
#N canvas 554 317 371 387 soundfile_playback 0;
#X obj 92 206 readsf~;
#X obj 187 106 openpanel;
#X msg 187 137 open \$1;
#X obj 92 284 outlet~;
#X obj 41 19 inlet;
#X obj 187 20 inlet;
#X connect 0 0 3 0;
#X connect 1 0 2 0;
#X connect 2 0 0 0;
#X connect 4 0 0 0;
#X connect 5 0 1 0;
#X restore 177 91 pd soundfile_playback;
#X obj 405 60 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X msg 215 53 start;
#X msg 154 52 stop;
#X msg 861 243 0.2;
#X msg 1079 222 58;
#X msg 1235 310 30;
#X obj 1109 110 loadbang;
#X connect 0 0 4 2;
#X connect 1 0 2 1;
#X connect 2 0 4 0;
#X connect 4 0 5 0;
#X connect 4 0 8 0;
#X connect 4 1 3 0;
#X connect 8 0 6 0;
#X connect 8 0 6 1;
#X connect 9 0 8 1;
#X connect 11 0 12 0;
#X connect 12 0 15 0;
#X connect 13 0 18 0;
#X connect 14 0 11 0;
#X connect 15 0 4 1;
#X connect 16 0 15 1;
#X connect 16 0 17 0;
#X connect 17 0 12 1;
#X connect 18 0 17 0;
#X connect 18 1 17 1;
#X connect 19 0 2 0;
#X connect 20 0 19 1;
#X connect 21 0 19 0;
#X connect 22 0 19 0;
#X connect 23 0 14 0;
#X connect 24 0 13 0;
#X connect 25 0 16 0;
#X connect 26 0 23 0;
#X connect 26 0 24 0;
#X connect 26 0 25 0;
